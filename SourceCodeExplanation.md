<font size="10">**DEPRECATED**</font>
<br><br><br><br>

## **Some explanation of source code**
- `Chat.cs` - Implements chat integration.
  - Chat part of the bot is started with `Chat.Start()` function.
  - After `Chat.Start()` is called:
    - Automated responses are loaded with `LoadResponseMessages()`,
    - Then new `Thread` is started in which chat part of the bot will be running,
    - Inside created `Thread` new `Socket` with `Tcp` parameters is created - it will be used to receive and send messages,
    - Then `BackgroundWorker` is created for asynchronous handling of messages receiving.
    - Then to created `BackgroundWorker` is assigned new function (delegate) which would be executed when `BackgroundWorker.Start()` is called,
    - Below that function infinite `while` loop is created to handle connecting to IRC server and starting / stopping `BackgroundWorker`,
    - Inside the infinite `while` loop created `Socket` tries to connect (`socket.Connect()`) to Twitch IRC address on predefined port,
    - Next starts created `BackgroundWorker` (`receiveWorker.RunWorkerAsync()`) and sends required information to log in into IRC chat with `socket.Send()`,
    - The main `Thread` of `Chat.cs` is then put to sleep while connection is active,
    - If the connection to Twitch IRC is closed the `BackgroundWorker` is stopped and the main `Thread` waits 2 seconds to try connecting again.
  - Inside `receiveWorker.DoWork()`:
    - `while` loop is used to continue receiving messages while connection is active,
    - `ManualResetEvent` with asynchronous functions `socket.BeginReceive()` and `socket.EndReceive()` is used to asynchronously receive messages and to act like it's event driven,
    - `socket.BeginReceive()` starts receiving message. When the message is received `socket.BeginReceive()` calls `AsyncCallback` declared in it's call,
    - Receive of the message is ended with `socket.EndReceive()` call,
    - Next received `bytes` are converted to `string[]` with use of `Split()`. Every IRC message send by Twitch have to end with "`\r\n`",
    - If the message doesn't end with "`\r\n`" probably fragmented message is received (IRC packet can't exceed 4096 bytes) so that message is moved to beggining of `receiveBuffer` and new messages are appended after it,
    - Received message is then split into "head" (`message[0]`) and "body" (`message[1]`) part. In which "head" is IRC specific data and "body" is the actual message send by the user. This approach doesn't allow users to mess with the bot.
    - Then each received message is parsed. In the parsing process static keywords like "`PING`", "`PRIVMSG`", etc. are being searched in "head" part of the message.
  - Inside `LoadResponseMessages()` configuration file `ResponseMessages.csv` is being parsed and keys are added to `Dictionary<string, (string, DateTime)>`. Each key in that dictionary uses `Tuple` as value - `Item1` of that tuple is actual message that should be send to chat and `Item2` is timestamp when that message was last being send. Sending automated messages checks if passed more than `CooldownBetweenTheSameMessage` time from last message send.
- `Events.cs` - Implements events integration.
  - Event part of the bot is started with `Events.Start()` function.
  - After `Events.Start()` is called:
    - HTTP tunnel to local server is created with `GetLocalTunnel()` call. If creation of HTTP tunnel fails the `Events` initialization process is interrupted. Without that tunnel other parts of `Events` wouldn't work,
    - Then local server is created with `LocalServer.Start()`,
    - Then new app access token (and if required user access token) is acquired  with `GetNewAccessToken()` call,
    - In subscriptions `POST` messages broadcaster ID is required but it could be troublesome for random user to know that so from defined `ChannelName` in `Config.ini` broadcasterID is acquired ,
    - Then previously subscribed events are acquired and deleted. Why? Because ngrok tunnel URL could change and previous subscriptions wouldn't work anymore,
    - Then `new Thread()` is stated for listening to Twitch event messages redirected by ngrok to local server,
    - Then subscribing to Twitch events is carried out with `POST` requests.
  - Inside `GetNewAccessToken()`:
    - If user access token is being required:
      - New web browser tab is being opened with link to provide the bot required permissions,
      - If the user provides the bot permissions the callback redirects user click to local server,
      - The acquired authentication token is visible in URL so the bot quickly redirects the user to hide it,
      - Then with acquired authentication token bot acquires user access token.
    - App access token is acquired with bot `BotClientID` and `BotSecret` configured in `Config.ini`.
  - Inside `GetLocalTunnel()`:
    - At first "`ngrok.exe`" presence is being checked,
    - Then new `cmd.exe` process that runs `ngrok.exe` is being created. `Ngrok.exe` have to be running as long as HTTP tunnel to local server have to be active,
    - Then using `ngrok` api tunnel URL is being acquired.
  - Inside `ParseServerRequest()`:
    - Received `Json` objects are being parsed.
  - Inside `ClearPreviousEventSubscriptions()`:
    - Firstly previous subscriptions are being acquired with `GET` request,
    - Then each acquired subscription is being deleted with `DELETE` request.
  - `ParseSubscribeResponse()` is being used to parse subscribe `POST` request. If the bot doesn't have permissions to subscribe to required event Twitch API sends it in `POST` request response not actual event message.
  - `GetTTS()` is being used to acquire audio stream from StreamElements api.
- `Audio.cs` - Implements playing audio clips. For now there is only one function `PlaySound()` to create new audio playing object. The call to it is created in `Events.GetTTS()` in which it's encapsulated in `new Thread` so each new sound is a `new Thread` and they could be playing at the same time. Some buffering is required to be implemented.
- `Config.cs` - Implements bot configuration from Config.ini file. Creates new `Config.ini` file if the file is missing. Parses `Config.ini` file and if some errors are found notifies the user.